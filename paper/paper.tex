%----------------------------------------------------------------------------------------
%	CONFIGURATIE VAN HET DOCUMENT
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{graphicx} 		% Voor het gebruik van afbeeldingen
\usepackage{natbib} 		% Voor de stijl van het document
\usepackage{amsmath} 		% Nodig voor het gebruik van bepaalde wiskunde-elementen
\usepackage{wrapfig}		% Nodig voor het 'wrappen' van de tekst om de afbeelding heen
\usepackage{algorithmic}	% Voor het schrijven van pseudo-code
\usepackage[]{algorithm2e}	% "
\setlength\parindent{0pt} 	% Haalt indentaties van paragrafen weg

%----------------------------------------------------------------------------------------
%	TITELPAGINA
%----------------------------------------------------------------------------------------

\begin{document}

\input{./title_page.tex}	% Importeert title_page.tex

%----------------------------------------------------------------------------------------
%	INHOUDSOPGAVE
%----------------------------------------------------------------------------------------

\renewcommand*\contentsname{Inhoudsopgave}
\tableofcontents{}
\pagebreak

%----------------------------------------------------------------------------------------
%	INLEIDING
%----------------------------------------------------------------------------------------

\section{Inleiding}
Dit paper zal gaan over het Graaf Isomorfisme probleem, en hoe dit effici\"ent gemaakt kan worden door middel van preprocessing. Het Graaf Isomorfisme probleem is een bekend probleem in de wiskunde en de informatica, wat het belangrijk maakt om dit op een zo snel mogelijke manier op te lossen. Als eerst wordt hierover (en over het algoritme wat wij hiervoor gebruiken) het een en ander uitgelegd. We zullen ook verschillende manieren van preprocessing bespreken, en toelichten waarom deze methoden geldig zijn binnen dit probleem. Daarna zullen we door middel van een experiment testen of deze methoden werken en wat het effect hiervan is op de snelheid en effici\"entie van ons algoritme. We sluiten dit document af met de conclusie.
\pagebreak

%----------------------------------------------------------------------------------------
%	SECTIE 1: HET GI PROBLEEM
%----------------------------------------------------------------------------------------

\section{Het Graaf Isomorfisme (GI) probleem}
Het Graaf Isomorfisme probleem is het probleem dat gaat over het vaststellen of twee grafen isomorf zijn, dat wil zeggen structureel gelijk aan elkaar. Als twee wiskundige objecten isomorf zijn, dan is elke eigenschap, waarvan de structuur bewaard blijft door een isomorfisme en die geldt voor een van de twee wiskundige objecten, ook geldt voor het andere wiskundige object.\\

\begin{wrapfigure}{r}{0.5\textwidth}
\begin{center}
\includegraphics[width=0.48\textwidth]{img/isomorphic.png}
\end{center}
\caption{Twee isomorfe grafen}
\end{wrapfigure}

Hoewel het op het eerste gezicht niet zo lijkt te zijn, geldt er een isomorfisme tussen de twee grafen hiernaast. Voor elke vertice van de eerste graaf geldt dat de buren daarvan exact hetzelfde zijn als de buren van diezelfde vertice in de tweede graaf.\\

Een methode om isomorfisme vast te kunnen stellen tussen deze twee grafen is ‘color refinement’. Dit algoritme kent kleuren toe aan de verschillende vertices, die een indicatie geeft welke buren deze vertice heeft. De groene vertice bijvoorbeeld heeft in de eerste graaf drie buren: de lichtblauwe, de roze en de gele. Dit geldt ook voor de tweede graaf. Als dit voor elke vertice in de twee grafen geldt, zijn ze isomorf. Dit kan als volgt gecontroleerd worden: wanneer de lijst met alle kleuren (zonder duplicaten) van de eerste graaf gelijk is aan die van de tweede graaf, kan er gezegd worden dat ze isomorf zijn ten opzichte van elkaar. In de afbeelding hierboven is dat ook het geval.
Dit is een goede manier om isomorfisme te controleren, omdat het op het eerste gezicht bij deze afbeelding lijkt alsof de twee grafen niet isomorf zijn. Ook is deze methode nuttig bij grotere grafen met veel vertices.

\subsection{Relevantie van het GI probleem}
Nu duidelijk gemaakt is wat het GI probleem inhoudt en hoe het gecontroleerd kan worden, blijft de vraag hoe relevant dit probleem is voor de Discrete Wiskunde. Waarom willen we weten of twee grafen (of zelfs wiskundige problemen in het algemeen) isomorf zijn ten opzichte van elkaar?\\

Isomorfisme heeft al voor het oplossen van vele wiskundige problemen gezorgd. Dat kan als volgt gedaan worden: een nog op te lossen wiskundig probleem X kan herleid worden tot een eenvoudiger probleem Y, wat makkelijker te begrijpen is. Neem een reeds opgelost probleem Z. Als aangetoond kan worden dat Y en Z isomorf zijn ten opzichte van elkaar, kan de conclusie getrokken worden dat op dat moment probleem X ook opgelost is (omdat probleem X, Y en Z structureel hetzelfde zijn). In de Discrete Wiskunde zijn er al veel problemen met deze methode opgelost, wat het controleren op isomorfisme erg relevant maakt.
Naast de wiskunde is het ook nuttig voor de informatica, omdat daar veel structuren als grafen weergegeven worden (denk aan netwerksystemen).

\subsection{Speciale gevallen}
Er zijn een aantal speciale gevallen waarvan bewezen is dat het in polynomiale tijd opgelost kan worden. Het eerste geval is een graaf die een boomstructuur heeft, dat wil zeggen: elk punt is met een ander punt verbonden, zonder cycli.\\
De tweede zijn de planaire grafen, dat zijn de grafen die zo in het platte vlak getekend kunnen worden dat geen van de randen een andere rand kruist. Ook als je een restrictie legt op het aantal keren dat de randen elkaar minimaal kruisen, of als je een restrictie legt op de maximale graad van alle hoekpunten is het in polynomiale tijd op te lossen.
\pagebreak

%----------------------------------------------------------------------------------------
%	SECTIE 2: ONS ALGORITME
%----------------------------------------------------------------------------------------

\section{Ons algoritme}
Voordat we color refinement toepassen geven we eerst elke vertice van de graaf een kleur die gelijk staat aan zijn degree. Het kleuren zelf gebeurt niet in de graaf zelf. De kleur van elke vertice wordt bijgehouden door 2 arrays. De eerste array houd voor elke kleur bij welke vertices daar bij horen. De tweede array houd voor elke vertice bij welke kleur hij heeft. Op deze manier hebben we de graaf zelf (bijna) niet meer nodig en kunnen we alle bewerkingen op de twee arrays uitvoeren. Na de initi\"ele kleuring voeren we color refinement uit over de lijsten. Als blijkt dat er nu geen duplicate kleuren meet zijn binnen elke graaf (d.w.z. binnen een graaf bestaan er geen twee vertices met dezelfde kleur) is het klaar en kunnen we controleren welke graven isomorf zijn. Zijn er wel duplicate kleuren dan moet `individual refiment' toegepast worden. Individual refinement wordt alleen toegepast op de graven met duplicate kleuren. Dit algoritme zoekt van twee graven alle duplicate kleuren van dezelfde kleur en vervangt dan de kleur van een van de duplicate vertices in graaf 1 en een graaf 2 door een nieuwe kleur. Hierna wordt color refinement opnieuw toegepast. Als er nog steeds duplicate kleuren bestaan wordt color refinement nogmaals toegepast. Als er een isomorfisme aangetoond kan worden wordt individual refinement over een ander koppel graven toegepast. Is er geen isomorfisme dan wordt de herkleuring van graaf 1 en graaf 2 teruggedraaid en wordt er een andere duplicate kleur van graaf 2 vervangen waarna het algoritme zich weer herhaald. 

% Voordat we het color refinement-algoritme toe gaan passen, beginnen we met het triviaal kleuren van elke vertice van de graaf. Dit doen we door elke vertice een kleur te geven die correspondeert aan zijn degree. We kleuren de vertices door een lijst van de labels van de vertices met dezelfde kleur in een array de zetten. De kleur van de vertices in de lijst overeenkomt met de index van de lijst in de array (alle vertices met kleur 0 staan op index 0 in de array). Tevens maken we een lijst met kleuren waarin de index in die lijst correspondeert met de label van de vertice (de kleur van vertice 17 staat op index 17 in de lijst). We zetten bewust geen vertices maar labels in de lijst omdat dat bij het maken van kopie\"en (met name deepcopies) veel ruimte scheelt. Ook hoeven we op deze manier nooit meer een vertice in de graven zelf aan te passen en kunnen we alle bewerkingen op de twee lijsten uitvoeren. Nu voeren we het color refinement-algoritme uit over de lijsten. In bepaalde gevallen kan het zijn dat alle elke graaf bestaat uit een set vertices met elke een andere kleur of duidelijk is dat geen enkele graaf isomorf is met elkaar. Helaas komt het vaak voor dat na het uitvoeren van color refinement het nog niet duidelijk is of 2 graven isomorf zijn of niet doordat de kleur van elke vertice binnen een graaf niet uniek is. Om dan toch uitsluitsel te geven over eventuele isomorfisme moet het zogeheten `individual refinement' toegepast worden. Dit algoritme zoekt van een graaf waarin een kleur twee of meer keer voor komt alle graven die ook dubbele vertices met dezelfde kleur op. Daarna vervangt hij de kleur van een van de dubbele vertices in een graaf door een nieuwe kleur en doet dit gebeurt ook voor een van de andere gevonden graven. Na het vervangen van de kleuren word color refinement weer toegepast op de twee aangepaste graven. Als hierna blijkt dat er nog steeds dubbele kleuren in de graven zitten word individual refinement nog een keer toegepast op deze twee graven. Als blijkt dat de twee graven isomorf zijn word er gekeken naar een ander graven paar met dubbele kleuren zijn ze niet isomorf dan wordt van de tweede graaf de kleur van een andere dubbel vertice aangepast en herhaald het algoritme zich opnieuw.
\pagebreak

%----------------------------------------------------------------------------------------
%	SECTIE 3: PREPROCESSING
%----------------------------------------------------------------------------------------

\section{Preprocessing}
Om het algoritme een handje te helpen bij het effeci\"ent oplossen van het GI probleem, kunnen er voor het color refinement-algoritme al stappen ondernomen worden, zodat het algoritme zelf minder tijd nodig heeft en dus het algoritme sneller en effeci\"enter wordt.
Voor het algoritme kunnen er namelijk grafen ge\"elimineerd worden uit de lijst die niet in aanmerking komen om isomorf te zijn met een andere graaf uit de lijst. Als je van tevoren deze grafen uit de lijst haalt, hoeft het color refinement-algoritme minder grafen te behandelen, waardoor het effeci\"enter wordt.

Voor het testen gebruik je een lijst van grafen, bijvoorbeeld een lijst met 4 grafen. Als er \'e\'en graaf is in de lijst die een van de eigenschappen van het preprocessing niet heeft en de andere drie wel, kan deze graaf uit de lijst gehaald worden. Het is dan namelijk niet meer mogelijk dat deze graaf isomorf is met \'e\'en van de andere grafen. Maar als twee grafen de eigenschappen wel hebben en twee niet, zetten we deze paren van grafen in twee aparte lijsten, waar vervolgens het color refinement-algoritme op uitgevoerd kan worden.

\subsection{Methoden}
We controleren de grafen van tevoren op de volgende eigenschappen:
\subsubsection{Grootte}
De grootte van de graaf, d.w.z. het aantal vertices en het aantal edges. Als er in de lijst één graaf is met een ander aantal vertices of edges dan de andere grafen, kan deze graaf uit de lijst gehaald worden. Hij kan dan niet meer isomorf zijn met een andere graaf. De pseudo-code voor het testen op grootte staat hieronder:\\

\begin{algorithm}[H]
	\KwData{Een lijst van grafen}
	\KwResult{Een lijst van grafen die mogelijk isomorf zijn}
	resultaat = lege lijst\\
	\For{Elke graaf i in de lijst}{
		\For{Elke andere graaf j in de lijst}{
			\If{Het aantal vertices van graaf i en j zijn gelijk}{
				\If{Het aantal edges van graaf i en j zijn gelijk}{
					Voeg i en j toe aan het resultaat
				}
			}
		}
	}
	\Return resultaat
\end{algorithm}

\subsubsection{Connectiviteit}
Als een graaf als enige in de lijst niet ‘connected’ is (en de andere grafen dus wel), kan deze ook ge\"elimineerd worden. Met een combinatie van deze eerste twee eigenschappen wordt ook gelijk gecontroleerd op het feit of een graaf een boom is of niet. Als twee ‘connected’ grafen een gelijk aantal vertices en edges hebben, zijn ze namelijk beide een boom of beide niet. Hier hoeft dus niet meer op gecontroleerd te worden. De pseudo-code voor het testen op connectiviteit staat hieronder:\\

\begin{algorithm}[H]
	\KwData{Een lijst van grafen}
	\KwResult{Een lijst van grafen die mogelijk isomorf zijn}
	resultaat = lege lijst\\
	\For{Elke graaf i in de lijst}{
		\For{Elke andere graaf j in de lijst}{
			\If{Grafen i en j zijn beide connected}{
				Voeg i en j toe aan het resultaat
			}
		}
	}
	\Return resultaat
\end{algorithm}\\
\vspace{5mm}

In de If-statement staat dat we controleren of beide grafen i en j connected zijn. Hier is geen standaard functie voor beschikbaar, dus we hebben zelf een algoritme geschreven (dat je op een graaf kunt uitroepen) dat teruggeeft of een graaf connected is of niet. De pseudo-code hiervan staat hieronder beschreven:\\

\begin{algorithm}[H]
	\KwData{De graaf zelf}
	\KwResult{True als hij connected is, anders False}\\

	x = een willekeurige vertex\\
	L = een lijst van vertices bereikbaar vanaf x\\
	K = een lijst van vertices die nog ontdekt moeten worden\\
	Aan het begin van het algoritme geldt L = K = x\\

	\While{K is niet leeg}{
		Vind een vertex y in K en haal deze eruit\\
		\For{elke edge (y,z)}{
			\If{z zit niet in L}{
				Voeg z toe aan L en K\\
			}
		}
	}
	\eIf{L heeft minder dan n elementen}{
		\Return False
	}{\Return True}

\end{algorithm}

\subsubsection{False twins}
Na afloop van het (voor de eerste keer) uitvoeren van het color refinement-algoritme, kan er nog een stap ondernomen worden voordat we verder gaan met het ‘individual refinement’. Er kan namelijk gekeken worden of twee grafen ‘false twins’ hebben. Dit zijn twee vertices die in de graaf exact dezelfde buren hebben. Als er in de lijst een graaf is die als enige false twins heeft, kan deze niet meer isomorf zijn met \'e\'en van de andere grafen.

\subsection{Validatie preprocessing methoden}

Een isomorfisme is een bijectieve afbeelding $f:V(G) \rightarrow V(H)$ zodanig dat $\forall u,v \in V(G)$ er geldt dat $uv \in E(G) \Leftrightarrow f(u)f(v)\in E(H)$.\\

We hebben 3 preprocessing stappen gemaakt.
\begin{enumerate}
\item Als $|V(G)|\neq|V(H)|$ dan kan er geen isomorfisme bestaan.
\item Als $|E(G)|\neq|E(H)|$ dan kan er geen isomorfisme bestaan.
\item Als een graaf wel `connected' is en de andere niet, dan kan er geen isomorfisme bestaan.
\end{enumerate}

Nu volgt het bewijs dat twee grafen niet isomorf zijn als aan een van de volgende 3 voorwaarden wordt voldaan:
\begin{enumerate}
\item Als $|V(G)|\neq|V(H)|$ dan kan je geen bijectie defini\"eren, want een bijectie moet one-to-one zijn, en daarvoor moeten beide sets evenveel elementen bevatten.
\item Als $|E(G)|\neq|E(H)|$ dan is er een tegenspraak met de eis dat $uv\in E(G)\Leftrightarrow f(u)f(v)\in E(H)$.
\item Neem aan dat $H$ connected is en $G$ niet. Zonder verlies van algemeenheid kunnen we aannemen dat $G$ bestaat uit twee delen die beide connected zijn, noem ze $G_1$ en $G_2$.

Neem nu aan dat er een isomorfisme tussen $G$ en $H$ bestaat. Deel $H$ op in twee delen, $H_1$ en $H_2$, zodanig dat $\forall g_1\in V(G_1)$ geldt dat $f(g_1)\in V(H_1)$ en $\forall g_2\in V(G_2)$ geldt dat $f(g_2)\in V(H_2)$.
Dan $\exists g_1\in G_1$ en $g_2\in G_2$ zodanig dat $g_1g_2\in E(G)$, terwijl $f(g_1)f(g_2)\notin E(H)$. Dit levert een tegenspraak op.\\
Dus de grafen moeten beide wel of beide niet connected zijn.
\end{enumerate}

\pagebreak

%----------------------------------------------------------------------------------------
%	SECTIE 4: TESTEN
%----------------------------------------------------------------------------------------

\section{Testen}
Natuurlijk gaan we ons color refinement-algoritme en onze preprocessing-algoritmes ook nog testen. Er worden verschillende testinstanties (lijsten van grafen) aangeleverd die we kunnen gebruiken, en we kunnen ook onze eigen grafen ontwerpen om onze code op te testen. We testen ons project op twee delen:
\begin{itemize}
\item De werking van het color refinement-algoritme en het algoritme voor het controleren op automorfisme. Dit zijn verplichte onderdelen van het project, dus we zullen met verschillende grafen gaan testen of deze algoritmes ook naar behoren werken.
\item Het preprocessing. We testen hierbij eerst of de verschillende manieren van preprocessing werken, en vervolgens gaan we een experiment doen dat (hopelijk) aan gaat tonen dat preprocessing ook het gehele proces sneller en effeci\"enter maakt.
\end{itemize}
\pagebreak

%----------------------------------------------------------------------------------------
%	SECTIE 5: CONCLUSIE
%----------------------------------------------------------------------------------------

\section{Conclusie}
--Volgt nog--
\pagebreak

\end{document}