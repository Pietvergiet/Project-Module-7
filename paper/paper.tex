%----------------------------------------------------------------------------------------
%	CONFIGURATIE VAN HET DOCUMENT
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{graphicx} 					% Voor het gebruik van afbeeldingen
\usepackage[square,numbers]{natbib} 	% Voor de bibliografie aan het eind
\usepackage{amsmath} 					% Nodig voor het gebruik van bepaalde wiskunde-elementen
\usepackage{wrapfig}					% Nodig voor het 'wrappen' van de tekst om de afbeelding heen
\usepackage{algorithmic}				% Voor het schrijven van pseudo-code
\usepackage[]{algorithm2e}				% "

\setlength\parindent{0pt} 				% Haalt indentaties van paragrafen weg

\begin{document}

%----------------------------------------------------------------------------------------
%	TITELPAGINA
%----------------------------------------------------------------------------------------

\begin{titlepage}
		\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
		\center 		% Centreer alles op de pagina
		 
		%----------------------------------------------------------------------------------------
		%	HEADER SECTIE
		%----------------------------------------------------------------------------------------

		\textsc{\large Universiteit Twente}\\[1.5cm]
		Module 7 - 201400433\\
		\vspace{5mm}
		\textsc{\Large Discrete Structuren \& Effici\"ente Algoritmes}\\[0.5cm]
		\vspace{15mm}

		%----------------------------------------------------------------------------------------
		%	TITEL SECTIE
		%----------------------------------------------------------------------------------------

		\HRule \\[0.4cm]
		{ \huge \bfseries Preprocessing methoden}\\[0.4cm]
		{ \large \bfseries Het effici\"ent maken van het Graaf Isormorfisme probleem}\\[0.4cm]
		\HRule \\[1.5cm]
		 
		%----------------------------------------------------------------------------------------
		%	AUTEUR(S) SECTIE
		%----------------------------------------------------------------------------------------

		Projectgroep 1\\
		\vspace{10mm}
		\begin{minipage}{0.4\textwidth}
		\begin{flushleft} \large
		\emph{Auteurs:}\\
		Joeri Kock\\
		Remco Brunsveld\\
		Frank Bruggink\\
		Dani\"el Schut
		\end{flushleft}
		\end{minipage}
		~
		\begin{minipage}{0.4\textwidth}
		\begin{flushright} \large
		\emph{Projectbegeleider:} \\
		Prof. Dr. J.C. van de Pol
		\end{flushright}
		\end{minipage}\\[4cm]

		%----------------------------------------------------------------------------------------
		%	DATUM SECTIE
		%----------------------------------------------------------------------------------------

		{\large \today}\\[3cm]

		\pagebreak 			% Vul de rest van de pagina met witregels

\end{titlepage}

%----------------------------------------------------------------------------------------
%	INHOUDSOPGAVE
%----------------------------------------------------------------------------------------

\renewcommand*\contentsname{Inhoudsopgave}
\tableofcontents{}
\pagebreak

%----------------------------------------------------------------------------------------
%	SECTIE 1: INLEIDING
%----------------------------------------------------------------------------------------

\section{Inleiding}
Dit paper zal gaan over het Graaf Isomorfisme probleem, en hoe dit effici\"ent gemaakt kan worden door middel van preprocessing. Het Graaf Isomorfisme probleem is een bekend probleem in de wiskunde en de informatica, wat het belangrijk maakt om dit op een zo snel mogelijke manier op te lossen. Als eerst wordt hierover (en over het algoritme wat wij hiervoor gebruiken) het een en ander uitgelegd. We zullen ook verschillende manieren van preprocessing bespreken, en toelichten waarom deze methoden geldig zijn binnen dit probleem. Daarna zullen we door middel van een experiment testen of deze methoden werken en wat het effect hiervan is op de snelheid en effici\"entie van ons algoritme. We sluiten dit document af met de conclusie.
\pagebreak

%----------------------------------------------------------------------------------------
%	SECTIE 2: HET GI PROBLEEM
%----------------------------------------------------------------------------------------

\section{Het Graaf Isomorfisme (GI) probleem}
Het Graaf Isomorfisme probleem is het probleem dat gaat over het vaststellen of twee grafen isomorf zijn, dat wil zeggen structureel gelijk aan elkaar. Als twee wiskundige objecten isomorf zijn, dan is elke eigenschap, waarvan de structuur bewaard blijft door een isomorfisme en die geldt voor een van de twee wiskundige objecten, ook geldt voor het andere wiskundige object.\\

\begin{wrapfigure}{r}{0.5\textwidth}
\renewcommand{\figurename}{Figuur}
\begin{center}
\includegraphics[width=0.48\textwidth]{img/isomorphic.png}
\end{center}
\caption{Twee isomorfe grafen}
\end{wrapfigure}

Hoewel het op het eerste gezicht niet zo lijkt te zijn, geldt er een isomorfisme tussen de twee grafen hiernaast. Voor elke vertice van de eerste graaf geldt dat de buren daarvan exact hetzelfde zijn als de buren van diezelfde vertice in de tweede graaf.\\

Een methode om isomorfisme vast te kunnen stellen tussen deze twee grafen is ‘color refinement’. Dit algoritme kent kleuren toe aan de verschillende vertices, die een indicatie geeft welke buren deze vertice heeft. De groene vertice bijvoorbeeld heeft in de eerste graaf drie buren: de lichtblauwe, de roze en de gele. Dit geldt ook voor de tweede graaf. Als dit voor elke vertice in de twee grafen geldt, zijn ze isomorf. Dit kan als volgt gecontroleerd worden: wanneer de lijst met alle kleuren (zonder duplicaten) van de eerste graaf gelijk is aan die van de tweede graaf, kan er gezegd worden dat ze isomorf zijn ten opzichte van elkaar. In de afbeelding hierboven is dat ook het geval.
Dit is een goede manier om isomorfisme te controleren, omdat het op het eerste gezicht bij deze afbeelding lijkt alsof de twee grafen niet isomorf zijn. Ook is deze methode nuttig bij grotere grafen met veel vertices.

\subsection{Relevantie van het GI probleem}
Nu duidelijk gemaakt is wat het GI probleem inhoudt en hoe het gecontroleerd kan worden, blijft de vraag hoe relevant dit probleem is voor de Discrete Wiskunde. Waarom willen we weten of twee grafen (of zelfs wiskundige problemen in het algemeen) isomorf zijn ten opzichte van elkaar?\\

Isomorfisme heeft al voor het oplossen van vele wiskundige problemen gezorgd. Dat kan als volgt gedaan worden: een nog op te lossen wiskundig probleem X kan herleid worden tot een eenvoudiger probleem Y, wat makkelijker te begrijpen is. Neem een reeds opgelost probleem Z. Als aangetoond kan worden dat Y en Z isomorf zijn ten opzichte van elkaar, kan de conclusie getrokken worden dat op dat moment probleem X ook opgelost is (omdat probleem X, Y en Z structureel hetzelfde zijn). In de Discrete Wiskunde zijn er al veel problemen met deze methode opgelost, wat het controleren op isomorfisme erg relevant maakt.
Naast de wiskunde is het ook nuttig voor de informatica, omdat daar veel structuren als grafen weergegeven worden (denk aan netwerksystemen).

\subsection{Speciale gevallen}
Er zijn een aantal speciale gevallen waarvan bewezen is dat het in polynomiale tijd opgelost kan worden. Het eerste geval is een graaf die een boomstructuur heeft, dat wil zeggen: elk punt is met een ander punt verbonden, zonder cycli.\\
De tweede zijn de planaire grafen, dat zijn de grafen die zo in het platte vlak getekend kunnen worden dat geen van de randen een andere rand kruist. Ook als je een restrictie legt op het aantal keren dat de randen elkaar minimaal kruisen, of als je een restrictie legt op de maximale graad van alle hoekpunten is het in polynomiale tijd op te lossen.
\pagebreak

%----------------------------------------------------------------------------------------
%	SECTIE 3: ONS ALGORITME
%----------------------------------------------------------------------------------------

\section{Ons algoritme}
Hier zullen we een korte uitleg geven over de implementatie van ons color refinement-algoritme.\\

Voordat we color refinement toepassen, geven we eerst elke vertice van de graaf een kleur die gelijk staat aan zijn degree. Het kleuren gebeurt niet in de graaf zelf, maar wordt apart bijgehouden door 2 arrays. De eerste array houdt voor elke kleur bij welke vertices die kleur hebben. De tweede array houdt voor elke vertice bij welke kleur hij heeft. Op deze manier hebben we de graaf zelf (bijna) niet meer nodig en kunnen we alle bewerkingen op de twee arrays uitvoeren, wat het proces sneller en overzichtelijker maakt.\\
Na de initi\"ele kleuring voeren we color refinement uit over de lijsten. Als blijkt dat er nu geen duplicate kleuren meer zijn binnen elke graaf (d.w.z. binnen een graaf bestaan er geen twee vertices met dezelfde kleur) is het klaar en kunnen we controleren welke graven isomorf zijn. Zijn er wel duplicate kleuren, dan moet `individual refiment' toegepast worden.\\

Individual refinement wordt alleen toegepast op de graven met duplicate kleuren. Het algoritme werkt als volgt: hij zoekt eerst een kleur op die bezet wordt door meerdere vertices. Vervolgens neemt hij \'e\'en van deze vertices, en vervangt zijn kleur. Bij beide grafen wordt hiervoor een andere (nieuwe) kleur gekozen.Hierna wordt color refinement opnieuw toegepast. Als er nog steeds duplicate kleuren bestaan wordt color refinement nogmaals toegepast. Als er een isomorfisme aangetoond kan worden, wordt individual refinement over een ander koppel graven toegepast. Is er geen isomorfisme dan wordt de herkleuring van graaf 1 en graaf 2 teruggedraaid en wordt er een andere duplicate kleur van graaf 2 vervangen, waarna het algoritme zich weer herhaalt. 
\pagebreak

%----------------------------------------------------------------------------------------
%	SECTIE 4: PREPROCESSING
%----------------------------------------------------------------------------------------

\section{Preprocessing}
Om het algoritme een handje te helpen bij het effici\"ent oplossen van het GI probleem, kunnen er voor het color refinement-algoritme al stappen ondernomen worden, zodat het algoritme zelf minder tijd nodig heeft en dus het algoritme sneller en effici\"enter wordt.
Voor het algoritme kunnen er namelijk grafen ge\"elimineerd worden uit de lijst die niet in aanmerking komen om isomorf te zijn met een andere graaf uit de lijst. Als je van tevoren deze grafen uit de lijst haalt, hoeft het color refinement-algoritme minder grafen te behandelen, waardoor het effici\"enter wordt.

Voor het testen gebruik je een lijst van grafen, bijvoorbeeld een lijst met 4 grafen. Als er \'e\'en graaf is in de lijst die een van de eigenschappen van het preprocessing niet heeft en de andere drie wel, kan deze graaf uit de lijst gehaald worden. Het is dan namelijk niet meer mogelijk dat deze graaf isomorf is met \'e\'en van de andere grafen. Maar als twee grafen de eigenschappen wel hebben en twee niet, zetten we deze paren van grafen in twee aparte lijsten, waar vervolgens het color refinement-algoritme op uitgevoerd kan worden.

\subsection{Methoden}
We controleren de grafen van tevoren op de volgende eigenschappen:
\subsubsection{Grootte}
De grootte van de graaf, d.w.z. het aantal vertices en het aantal edges. Als er in de lijst één graaf is met een ander aantal vertices of edges dan de andere grafen, kan deze graaf uit de lijst gehaald worden. Hij kan dan niet meer isomorf zijn met een andere graaf. De pseudo-code voor het testen op grootte staat hieronder:\\

\begin{algorithm}[H]
	\KwData{Een lijst van grafen}
	\KwResult{Een lijst van grafen die mogelijk isomorf zijn}
	resultaat = lege lijst\\
	\For{Elke graaf i in de lijst}{
		\For{Elke andere graaf j in de lijst}{
			\If{Het aantal vertices van graaf i en j zijn gelijk}{
				\If{Het aantal edges van graaf i en j zijn gelijk}{
					Voeg i en j toe aan het resultaat
				}
			}
		}
	}
	\Return resultaat
\end{algorithm}

\subsubsection{Connectiviteit}
Als een graaf als enige in de lijst niet ‘connected’ is (en de andere grafen dus wel), kan deze ook ge\"elimineerd worden. Met een combinatie van deze eerste twee eigenschappen wordt ook gelijk gecontroleerd op het feit of een graaf een boom is of niet. Als twee ‘connected’ grafen een gelijk aantal vertices en edges hebben, zijn ze namelijk beide een boom of beide niet. Hier hoeft dus niet meer op gecontroleerd te worden. De pseudo-code voor het testen op connectiviteit staat hieronder:\\

\begin{algorithm}[H]
	\KwData{Een lijst van grafen}
	\KwResult{Een lijst van grafen die mogelijk isomorf zijn}
	resultaat = lege lijst\\
	\For{Elke graaf i in de lijst}{
		\For{Elke andere graaf j in de lijst}{
			\If{Grafen i en j zijn beide connected}{
				Voeg i en j toe aan het resultaat
			}
		}
	}
	\Return resultaat
\end{algorithm}
\vspace{5mm}

In de If-statement staat dat we controleren of beide grafen i en j connected zijn. Hier is geen standaard functie voor beschikbaar, dus we hebben zelf een algoritme geschreven (dat je op een graaf kunt uitroepen) dat teruggeeft of een graaf connected is of niet. De pseudo-code hiervan staat hieronder beschreven:\\

\begin{algorithm}[H]
	\KwData{De graaf zelf}
	\KwResult{True als hij connected is, anders False}
	x = een willekeurige vertex\\
	L = een lijst van vertices bereikbaar vanaf x\\
	K = een lijst van vertices die nog ontdekt moeten worden\\
	Aan het begin van het algoritme geldt L = K = x\\

	\While{K is niet leeg}{
		Vind een vertex y in K en haal deze eruit\\
		\For{elke edge (y,z)}{
			\If{z zit niet in L}{
				Voeg z toe aan L en K\\
			}
		}
	}
	\eIf{L heeft minder dan n elementen}{
		\Return False
	}{\Return True}

\end{algorithm}

\subsection{Validatie preprocessing methoden}

Een isomorfisme is een bijectieve afbeelding $f:V(G) \rightarrow V(H)$ zodanig dat $\forall u,v \in V(G)$ er geldt dat $uv \in E(G) \Leftrightarrow f(u)f(v)\in E(H)$.\\

We hebben 3 preprocessing stappen gemaakt.
\begin{enumerate}
\item Als $|V(G)|\neq|V(H)|$ dan kan er geen isomorfisme bestaan.
\item Als $|E(G)|\neq|E(H)|$ dan kan er geen isomorfisme bestaan.
\item Als een graaf wel `connected' is en de andere niet, dan kan er geen isomorfisme bestaan.
\end{enumerate}

Nu volgt het bewijs dat twee grafen niet isomorf zijn als aan een van de volgende 3 voorwaarden wordt voldaan:
\begin{enumerate}
\item Als $|V(G)|\neq|V(H)|$ dan kan je geen bijectie defini\"eren, want een bijectie moet one-to-one zijn, en daarvoor moeten beide sets evenveel elementen bevatten.
\item Als $|E(G)|\neq|E(H)|$ dan is er een tegenspraak met de eis dat $uv\in E(G)\Leftrightarrow f(u)f(v)\in E(H)$.
\item Neem aan dat $H$ connected is en $G$ niet. Zonder verlies van algemeenheid kunnen we aannemen dat $G$ bestaat uit twee delen die beide connected zijn, noem ze $G_1$ en $G_2$.

Neem nu aan dat er een isomorfisme tussen $G$ en $H$ bestaat. Deel $H$ op in twee delen, $H_1$ en $H_2$, zodanig dat $\forall g_1\in V(G_1)$ geldt dat $f(g_1)\in V(H_1)$ en $\forall g_2\in V(G_2)$ geldt dat $f(g_2)\in V(H_2)$.
Dan $\exists g_1\in G_1$ en $g_2\in G_2$ zodanig dat $g_1g_2\in E(G)$, terwijl $f(g_1)f(g_2)\notin E(H)$. Dit levert een tegenspraak op.\\
Dus de grafen moeten beide wel of beide niet connected zijn.
\end{enumerate}

\pagebreak

%----------------------------------------------------------------------------------------
%	SECTIE 5: TESTEN
%----------------------------------------------------------------------------------------

\section{Testen}
Natuurlijk gaan we ons color refinement-algoritme en onze preprocessing-algoritmes ook nog testen. Er worden verschillende testinstanties (lijsten van grafen) aangeleverd die we kunnen gebruiken, en we kunnen ook onze eigen grafen ontwerpen om onze code op te testen. We testen ons project op twee delen:
\begin{itemize}
\item De werking van het color refinement-algoritme en het algoritme voor het controleren op automorfisme. Dit zijn verplichte onderdelen van het project, dus we zullen met verschillende grafen gaan testen of deze algoritmes ook naar behoren werken.
\item Het preprocessing. We testen hierbij eerst of de verschillende manieren van preprocessing werken, en vervolgens gaan we een experiment doen dat (hopelijk) aan gaat tonen dat preprocessing ook het gehele proces sneller en effici\"enter maakt.
\end{itemize}
\pagebreak

%----------------------------------------------------------------------------------------
%	SECTIE 6: CONCLUSIE
%----------------------------------------------------------------------------------------

\section{Conclusie}
--Volgt nog--
\pagebreak

%----------------------------------------------------------------------------------------
%	REFERENTIES
%----------------------------------------------------------------------------------------

\renewcommand{\refname}{Referenties}
\bibliographystyle{amsplain}
\bibliography{paper}

\end{document}